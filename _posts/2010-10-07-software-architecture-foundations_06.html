---
layout: post
title: 'Software Architecture: Foundations, Theory and Practice - Chapter 2'
date: '2010-10-07T03:23:00.001+02:00'
author: Monik
tags:
- Software_Architecture
modified_time: '2016-01-15T23:11:52.182+01:00'
blogger_id: tag:blogger.com,1999:blog-5940427300271272994.post-8520937441580135626
blogger_orig_url: http://learningmonik.blogspot.com/2010/10/software-architecture-foundations_06.html
commentIssueId: 5
type: book
---

<div dir="ltr" style="text-align: left;" trbidi="on"><i>These are my notes from the Chapter 2 from the book "<a href="http://www.softwarearchitecturebook.com/">Software Architecture: Foundations, Theory and Practice</a>".</i><br /><i><br /></i>Now we will see how <span style="font-weight: bold;">Software Architecture </span>relates to <span style="font-weight: bold;">Software Engineering</span>.<br /><br />We will reorientate these concepts away from their typical understanding. We will see that the architecture is most important.<br /><ol><li>Every app has an <span style="font-weight: bold;">architecture</span></li><li>Every app has an <span style="font-weight: bold;">architect</span></li><li>Architecture is <span style="font-weight: bold;">not a phase of development</span></li></ol>Architecture is set of <span style="font-weight: bold;">principal design decision</span><span style="font-weight: bold;">s</span> made about a system; characterization of the essence of the application.<br /><br />The traditional and <span style="font-style: italic;">inaccurate </span>interpretation is that the architecture is the product of particular phase in development, called preliminary design (or high-level design, product design) - but this term is in fact much broader.<br /><br />Now we will discuss the architecture in context of <span style="font-weight: bold;">waterfall </span>process:<br /><br /><span style="font-weight: bold;">1. Requirements</span><br /><br />- in theory the requirements should be isolated first, then the solution found and implemented; but in practice requirements analysis is done in quick, superficial manner, or not at all; why is that so? they explain it by tight schedules, budget constraints, ...  but the real reason might just be that <span style="font-weight: bold;">requirements do not create value, products do</span>; and after that the marketing people need to match the product to the needs, and even create the needs if neccessary..<br /><br />(...)<br /><br />...in some way current <span style="font-weight: bold;">architectures drive the requirements</span> - as we can see what have been done so far, how it works, what can be done and how; they provide a<span style="font-weight: bold;"> frame of reference</span>, a <span style="font-weight: bold;">vocabulary</span>, also a <span style="font-weight: bold;">base </span>for improvements - to create new architectures; this works only for majority of cases, but it can happen the thing is a <span style="font-weight: bold;">greenfield </span>development (with no architecture predecessor), though we have to be careful and extensively search for existing solutions before assuming the problem is totally new.<br /><br /><span style="font-weight: bold;">2.  Design</span><br /><br />Design is the phase of taking the<span style="font-weight: bold;"> principal design decisions</span> (the most important ones are taken now, the others can be taken later), with placing emphasis on architectural concerns.<br /><br />(...)<br /><br /><span style="font-weight: bold;">Design techniques:</span><br /><ol><li><span style="font-weight: bold;">OOD - Object Oriented Design</span> (...); this has also limitations<br />- it is not a complete design approach, i.e. it does not say anuything about many things, like security, use of commercial components<br />- it tries to view everything as object (so?!)<br />- it's very bound to programming language, so the programming language can start dictating what the important decisions are<br />- concern for concurrency is outside OOD purview<br />* UML helped to lift the discussion of OOD above the programming language </li><li><span style="font-weight: bold;">DSSA - Domain Specific Software Architecture</span><br />- used when prior experience and prior architectures can strongly influence new project<br />- DSSA is consistent with development of product lines<br />- while extracting the reusable parts very careful approach must be taken</li></ol><span style="font-weight: bold;">3. Implementation</span><br /><br />The task is to create <span style="font-weight: bold;">machine-executable source code </span>that is faithful to the architecture. The important things about implementation in architecture-centric view of SE are:<br /><ul><li>the implementation activity may add to or <span style="font-weight: bold;">modify </span>the architecture</li><li>architecture <span style="font-weight: bold;">does not </span>have to be completed <span style="font-weight: bold;">before </span>implementation begins - the only constraint is to keep the code consistent with the recorded architecture</li></ul>What is <span style="font-weight: bold;">faithful implementation</span>:<br /><ul><li>all structural <span style="font-weight: bold;">elements </span>in <span style="font-weight: bold;">architecture </span>are found in <span style="font-weight: bold;">source code </span>and vice versa</li><li>the source code cannot contain <span style="font-weight: bold;">connections </span>not present in the architecture</li></ul><span style="font-weight: bold;">Techniques </span>for assisting in faithful development from the design:<br /><ul><li><span style="font-weight: bold;">generation technologies</span><br />- if only available, is the best, as it <span style="font-weight: bold;">ensures consistency </span>between the architecture and the implementation; an example is parser generators<br />- this is only feasible in domains which are thoroughly understood and bounded</li><li><span style="font-weight: bold;">frameworks</span><br />- used when there's no generation available<br />- acts as a <span style="font-weight: bold;">bridge </span>between desired architecture style and implementation<br />- framework selection is a part of architecture-based system implementation; if there's no suitable framework, start from creating one by yourself</li><li><span style="font-weight: bold;">middleware</span><br />- it's software supporting <span style="font-weight: bold;">communication </span>between software components; it corresponds to the connectors<br />- e.g. CORBA, RPC</li><li><span style="font-weight: bold;">reuse</span><br />- it is ideal case when certain old component perfectly matches desired architecture; but in reality we need to make <span style="font-weight: bold;">choices</span>, depending to what extend it dismatches; we can <span style="font-weight: bold;">encapsulate </span>old component in new one, exposing only desired functionalities; we can <span style="font-weight: bold;">change the architecture </span>concept to match including the old component; or just give up on reuse and write the component from scratch</li></ul>When none of the assisting techniques are available for some reason, the whole software must be implemented manually - but we need to watch out not to make the real software architecure not consistent with the documented one; If we do not, then we can:<br /><ul><li>not be able to reason about <span style="font-weight: bold;">implemented application architecture</span></li><li><span style="font-weight: bold;">mislead </span>all stakeholders</li><li>doom any further <span style="font-weight: bold;">development based on the documented architecure </span>to failure</li></ul><span style="font-size: 130%;"><span style="font-weight: bold;"><span style="font-size: 100%;">4. Analysis and testing</span></span></span><br />It is an activity taken in order to asses the quality of an artifact. In traditional waterfall model the code is <span style="font-weight: bold;">first </span>written and then tested; however, testing <span style="font-weight: bold;">does not have to </span>happen after implementation, it can be <span style="font-weight: bold;">integrated </span>into development process; as the earlier the errors are discovered the lower cost of correcting them;<br /><br />Architecture-cenetered approach offers the opportunity for <span style="font-weight: bold;">early analysis</span>; we can test not only <span style="font-weight: bold;">functionality </span>but also <span style="font-weight: bold;">properties</span>; what exactly can we test about architecture model:<br /><ol><li><span style="font-weight: bold;">consistency</span>, <span style="font-weight: bold;">correctness</span>, <span style="font-weight: bold;">exhibition of desired non functional properties</span>,<span style="font-weight: bold;"> </span>and<span style="font-weight: bold;"> internal consistency </span>(e.g. by <span style="font-weight: bold;">dataflow analysis </span>on the architecture)</li><li>consistency with requirements</li><li>we can <span style="font-weight: bold;">base </span>our choice for <span style="font-weight: bold;">source code testing and analysis</span> methods based on the architecture model; architecture can also provide guidance and economies in development of <span style="font-weight: bold;">test harnesses</span> (automated test frameworks); (...)</li><li>it can help in detecting <span style="font-weight: bold;">inconsistency </span>between architecture model and the model derived from implemented code</li></ol>It all is to asses and improve the quality of systems.<br /><br /><span style="font-size: 100%;"><span style="font-weight: bold;">5. Evolution (maintenance)</span></span><br /><br />This is all the activities that chronologically follow the release of an application, for example <span style="font-weight: bold;">bug fixing</span>, major <span style="font-weight: bold;">additions </span>of new functionality, creation of <span style="font-weight: bold;">specialized versions </span>of the application;<br /><br />The thing is: whenever a change is required, we should <span style="font-weight: bold;">go back </span>to the phase where the issue is considered in - for example if we need new functionality, we should go back to the requirements phase - and then <span style="font-weight: bold;">moving forward in sequence </span>from there. But, in practice usually only the coding phase is revisited, as this is the easiest solution - but this results in <span style="font-weight: bold;">degradation </span>of application's <span style="font-weight: bold;">quality</span>.<br /><br />What does the architecture-centric approach to software development offer here:<br /><ul><li>before we change anything, we need to have <span style="font-weight: bold;">deep understanding</span>, do analysis of the problem and proposed change, etc; therefore,<br />- if we have a clear architecture and its faithful implementation then it is easier to do it<br />- if we don't have any clear architecture specified, or the code is inconsistent with the specified one, we need to do <span style="font-weight: bold;">reenginering </span>first (code=&gt;requirements=&gt;architecture design=&gt;new code) - which is tough, costly and time-consuming</li><li>after the analysis, we come up with different solutions to the problem and choose the best one; <span style="font-weight: bold;">before </span>making any changes to code we need to <span style="font-weight: bold;">modify the architecture model </span>(not the oppposite!) - to keep them <span style="font-weight: bold;">consistent</span></li></ul><br /><span style="font-size: 130%;"><span style="font-weight: bold;">Processes</span></span><br /><br />Software Architecture is not a phase of software development.<br /><br />(...)<br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">Turbine Visualisation of Software Development</span></span><br /><br />This model is to highlight the central role of software architecture. The <span style="font-weight: bold;">axis of the core is time </span>and the core itself represents the <span style="font-weight: bold;">product</span>. The <span style="font-weight: bold;">rings </span>around the core represent the <span style="font-weight: bold;">development phases and effort</span>. The ring's <span style="font-weight: bold;">height </span>stands for the <span style="font-weight: bold;">time </span>spent for that phase, and the ring's <span style="font-weight: bold;">volume </span>is for <span style="font-weight: bold;">investment </span>made during that ring.<br /><ul><li>we can represent the particular stage of development by showing a <span style="font-weight: bold;">cross-section </span>of the turbine - then in the core we can place the already existing elements of the software (e.g. reaquirements, design document)</li><li>we can have the core <span style="font-weight: bold;">already having some thickness </span>at the beginning - that means we already have some knowledge and resources carried forward from previous projects</li><li>one ring can be composed of <span style="font-weight: bold;">several parts </span>when cross-sectioned</li></ul>* Agile development does not in fact produce any particular architecture; therefore it is hard to resuse or maintain such software;<br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">Tween Peaks Model</span></span> (Nuseibeh, 2001)<br /><br />(this model is two pyramides, the one on the left is Requirements, and on the right is Architecture, and the more down the more in detail it is, and the development goes from up to the bottom, going from one pyramid to the other, and back..)<br /><ul><li>it emphasizes the co-development of requirements and architecture, incrementally elaborating details</li><li>it represents recent work in requirements engineering</li></ul>* Brook's law: "<span style="font-style: italic;">Adding people to late software makes it late</span>" - and architecture-centric approach helps to reduce that problem! (a little..;))<br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">A sum up</span></span><br /><br />The success of a software is <span style="font-weight: bold;">highly correlated </span>to <span style="font-weight: bold;">good architecture</span>. Although many companies tend to focus on the software development <span style="font-weight: bold;">process </span>itself, and on improving it - the primary focus should be the <span style="font-weight: bold;">architecture</span>, not the process, as the architecture it the thing that generates the <span style="font-weight: bold;">revenue </span>(dochód) for a company.</div>
