---
layout: post
title: Information Security (undergrad course)
date: '2010-10-07T04:13:00.000+02:00'
author: Monik
tags:
- Infomation_Security
modified_time: '2016-01-15T23:13:17.276+01:00'
blogger_id: tag:blogger.com,1999:blog-5940427300271272994.post-4408819089603181445
blogger_orig_url: http://learningmonik.blogspot.com/2010/10/madrosci-numer-jeden.html
commentIssueId: 4
---

<div dir="ltr" style="text-align: left;" trbidi="on"><span style="font-size: 130%;"><span style="font-weight: bold;">1. Modulo arithmetic</span></span><br /><br /><span style="font-style: italic;">Def.: a = b mod n &lt;=&gt; there exists such integer k that a-b = kn</span><br /><br />We say <span style="font-style: italic;">"a is congruent to b modulo n"</span>; n is the <span style="font-style: italic;">modulus</span>; b is the <span style="font-style: italic;">residuo</span>;<br /><br /><span style="font-weight: bold;">Theorems about modulo arithmetic:</span><br />a=b and b=c =&gt; a+c=b+d<br />a=b and b=c =&gt; ac=bd<br />a=b =&gt; a^s=b^s (proof by induction)<br /><br /><span style="font-weight: bold;">Lagrange Theorem:</span><br />x=y  =&gt; P(x)=P(y)<br /><br />What implies from Lagrange theorem:<br />* 61345 number we can write down like:<br />61345 = 6*10^4 + 1*10^3 + 3*10^2 + 4*10 + 5<br />* we can also represent the number in different base, in any base, let's say base "B":<br />61345(B) = 6*B^4 + 1*B^3 + 3*B^2 + 4*B + 5 = P(B)<br />* we can treat this as polynomial P(B); We know that for B=10 it gives the number 61345;<br /><br />Suppose we want to know what is 61345 congruent to in modulo 9 arithmetic. Because 10=1 mod 9, then what is 61345=P(10) congruent is equal to what is P(1) congruent. Let's put B=1:<br /><br />P(1) = 6 + 1 + 3 + 4 + 5 = 1 mod 9<br /><br />So 61345 is congruent to 1 mod 9. We notice that it is enough to add all digits in a number and divide it mod 9 to find out what the number is congruent to modulo 9.<br /><br />* but it is different with different n.<br /><br />* also thanks to that theorem we can prove incorrectness of high precision arithmetic calculations.<br /><br /><span style="font-style: italic;">Proof of Lagrange theorem: </span>by induction on the degree of polynomial<br />p(x) = a_n*x^n + a_n-1*x^(n-1) + ... + a_1*x + a_0<br />- for n = 0:<br />p(x) = a_0 = a_0 mod n = p(y) mod n<br />- for n = k:<br />p(x) = a_k*x^k + a_k-1*x^(k-1) + ... + a_1*x + a_0<br />p(y) = a_k*y^k + a_k-1*y^(k-1) + ... + a_1*y + a_0<br /><br />we notice that x^k+1 = y^k+1 mod n (Th3), and even that a_k+1*x^k+1 = a_k+1*y^k+1 mod n (Th2 + reflexivity). Adding these terms to both equations we get the case for n=k+1.<br /><br /><span style="font-weight: bold;">Partition Theorem: - ????</span><br /><br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">2. Group (G,+)</span></span><br /><br /><span style="font-style: italic;">1. is </span><span style="font-style: italic; font-weight: bold;">closed </span><span style="font-style: italic;">(x+y belongs to G)</span><br /><span style="font-style: italic;">2. is </span><span style="font-style: italic; font-weight: bold;">associative </span><span style="font-style: italic;">(x+(y+z)=(x+y)+z)</span><br /><span style="font-style: italic;">3. has additive </span><span style="font-style: italic; font-weight: bold;">identity element </span><span style="font-style: italic;">(x+e=x)</span><br /><span style="font-style: italic;">4. for each element has corresponding additive </span><span style="font-style: italic; font-weight: bold;">inverse element </span><span style="font-style: italic;">(x+y = e = y+x)</span><br /><span style="font-style: italic;">* if it also has </span><span style="font-style: italic; font-weight: bold;">commutivity </span><span style="font-style: italic;">property (x+y=y+x), it is called an </span><span style="font-style: italic; font-weight: bold;">Abelian group</span><br /><br />In modulo n arithmetics the numbers 0-(n-1) are called <span style="font-weight: bold;">class representatives.</span> In one class there will be all numbers congruent to class representative mod n.<br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">3. Relations</span></span><span style="font-style: italic;"><br /></span><br /><span style="font-style: italic;">Def.: relation is a subset of Cartesian product.</span><br /><br />Congruence is in fact a relation. It is an <span style="font-weight: bold;">equivalence relation</span>:<br /><span style="font-style: italic;">1. it's symmetric</span><br /><span style="font-style: italic;">2. it's transitive</span><br /><span style="font-style: italic;">3. it's reflexive</span><br /><span style="font-style: italic;"><br /></span><span style="font-size: 130%;"><span style="font-weight: bold;">4. Chinese Remainder Theorem</span></span><br /><br /><span style="font-family: times new roman;">Given a series of n coprime integers mi such that</span><br /><span style="font-family: courier new;">M = /\m_i = m_1 * m_2 * ... * m_n</span><span style="font-family: times new roman;"><br />and an integer x such that</span><br /><span style="font-family: courier new;">x = r_i mod m_i</span><span style="font-family: times new roman;">, for all </span><span style="font-family: courier new;">1&lt;=i&lt;= n </span><br /><span style="font-family: times new roman;">then there's only one integer y in the range </span><span style="font-family: courier new;"><span style="font-family: times new roman;"><span style="font-family: courier new;">0&lt;= x&lt;M-1</span>, where <span style="font-family: courier new;">y = x mod m_i</span></span></span><br /><span style="font-style: italic;">Proof: </span>let's assume x=r_i mod m_i and y=r_i mod m_i; then<br /><span style="font-family: courier new;">x=y mod m_i</span><br />, and this by  definition equals<br /><span style="font-family: courier new;">x-y=k_i*m_i</span>, for all i<br />because m_i are coprime, and x-y is a divisor of both k_i and m_i, it means x-y is a divisor of M.<br />x-y=kM<br />the only k which makes x-y be in range 0 to M-1 is k=0:<br />x-y=0 =&gt; x=y<br />Contradiction.<br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">5. Function</span></span><br /><br />Is a relation where first element of ordered pair can appear in 1 ordered pair.<br /><br /><span style="font-style: italic;">Def.: Function is ordered triple of sets (X,Y,F), X-domain, Y-codomain, F-function range, where F={(x,y)|x belongs to X, y belongs to Y} and each x is the 1st element in only one pair.</span><br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">6. CRT notation</span></span><br /><br />The notation: x=(1,2,4)_(3,4,5) is equal to set of equations:<br /><br />x = 1 mod 3 n<br />x = 2  mod 4<br />x = 4 mod 5<br /><br />This defines x unambigiously in interval 0 to 3*4*5-1.<br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">7. Euclidean algorithm</span></span><br /><br />a/b = k+r/b &lt;=&gt;&lt;=&gt;  a = b*k + r<br /><br />Euclidean algorithm uses the fact that gcd(a,b) = gcd(b,r). Why is that fact true?<br /><br /><span style="font-style: italic;">Proof: </span>let's denote:<br />(1)  gcd(a,b) = s(2)  gcd(b,r) = t<br /><br />a) a=l*s, as s divides a (1)<br />b=w*s, as s divides b (1)<br /><br />If we divided a/b we would get:<br /><br />a = b*k + r<br />=&gt; l*s = k*w*s + r<br />=&gt; l*s - k*w*s = r<br />=&gt; s*(l - k*w) = r<br />=&gt; r is a multiple of s<br /><br />but gcd(b,r) = t, so s&lt;=t  b) b=d*t, as t divides b (2)<br />r=e*t, as t divides r (2)<br /><br />If we divided a/b we would get:<br /><br />a = b*k + r<br />=&gt; a = d*t*k + e*t<br />=&gt; t*(d*k + e) = a<br />=&gt; t divides a and b = &gt; s&gt;=t<br /><br />a) and b) =&gt; t = s .<br /><br />* CRT multiplication is LINEAR with respect to number of digits of multiplied numbers!<br /><br /><span style="font-size: 130%;"><span style="font-weight: bold;">8. Finding inverse in modulo n arithmetic</span></span><br /><br />For inverse of x=1/m we want to find such y, that m*y = 1 mod n.<br /><br />How to do it in other way than guessing (gcd(m,n) = 1):<br /><br />n= k_1*m + r_1<br />m = k_2*f + r_2<br />f = ...<br />(...)<br />d = 1*z + 0<br /><br />then:<br />r_1 = k_1*m - nr_2 = k_2*f - m<br />(...)<br />0 = 1*z - d<br /><br />ahhh, just check&nbsp;<a href="http://pl.wikipedia.org/wiki/Algorytm_Euklidesa#Rozszerzony_algorytm_Euklidesa">wiki</a><br /><br />... until we get 1 = r*m-q*n =&gt; r*x = 1 mod n =&gt; r is inverse to x</div>
