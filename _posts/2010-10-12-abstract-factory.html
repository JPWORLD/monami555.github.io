---
layout: post
title: 'Design Patterns: Abstract Factory (Kit)'
date: '2010-10-12T14:38:00.003+02:00'
author: Monik
tags:
- Programming
- Code_Design
- Design_Patterns
modified_time: '2016-01-15T23:28:16.276+01:00'
blogger_id: tag:blogger.com,1999:blog-5940427300271272994.post-5802255362228284540
blogger_orig_url: http://learningmonik.blogspot.com/2010/10/abstract-factory.html
commentIssueId: 7
type: book
---

<div dir="ltr" style="text-align: left;" trbidi="on"><i>Summary on basis of the book ,,<a href="http://c2.com/cgi/wiki?DesignPatternsBook">Design Patterns: Elements of Reusable Object-Oriented Software</a>'', by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, Addison-Wesley, 1995.</i><br /><br /><pre>class CertainFactory extends Factory{<br /> @Override<br /> ProductA createProductA(){<br />    return new CertainProductA();<br /> }<br />}</pre>We do have an abstract Factory which defines an interface for instantiating object of general types. In implementing subclasses we instantiate objects as cetrain subtypes of the general types.<br /><br />We can use such pattern for example for a toolkit that supports multiple look-and-feel standards. Each standard will then have corresponding Factory subclass, and for each widget type a set of specific classes. Clients have no knowledge even of the concrete widgets, just of the abstract Factory and general widget types.<br /><br />We use it when we want to configure system with one of multiple <span style="font-weight: bold;">families of product</span>, and when we want to <span style="font-weight: bold;">impose a constraint</span> that objects specific for particular family should be used <span style="font-weight: bold;">together</span>; when we want to separate the <span style="font-weight: bold;">system</span> from its product <span style="font-weight: bold;">creation, composition and representation</span>; when we want to <span style="font-weight: bold;">hide the implementation </span>of products, i.e. when providing a <span style="font-weight: bold;">class library</span>;<br /><br /><span style="font-weight: bold;">Consequences and variations</span><br /><ul><li>the concrete Factory is usually created at <span style="font-weight: bold;">run-time</span></li><li><span style="font-weight: bold;">(-) </span>extending to use <span style="font-weight: bold;">new kinds of product</span> is difficult</li><li><span style="font-weight: bold;">(+) </span>it promotes <span style="font-weight: bold;">consistency</span> among the product families</li><li>concrete factories are usually <span style="font-weight: bold;">singletons</span></li><li>creating concrete product in concrete factories can be done either with <span style="font-weight: bold;">FactoryMethod</span> pattern (the disadvantage is we need a new concrete factory with overriden factory methods for each family), or with <span style="font-weight: bold;">Prototype</span> pattern (in this case we instantiate the factories with a set of prototypes of each product type - in this way we can reduce the number of required concrete factories)</li><li>instead of specifying a separate method for creating each product type we can have just <span style="font-weight: bold;">one parametrized method</span> - but this approach is less safe: all products have to have same subclass in case of statically types languages, and the client will not know anything about the specific object type - which causes a classic trade-off for a highly flexible and extensible interface;</li></ul></div>
